package hostingv4

import (
	"log"
	"strconv"

	"github.com/PabloPie/go-gandi/hosting"
)

type (
	// DiskSpec is an alias for the Hosting object
	DiskSpec = hosting.DiskSpec
	// Disk is an alias for the Hosting object
	Disk = hosting.Disk
	// DiskImage is an alias for the Hosting object
	DiskImage = hosting.DiskImage
	// DiskFilter is an alias for the Hosting object
	DiskFilter = hosting.DiskFilter
)

type diskv4 struct {
	ID       int    `xmlrpc:"id"`
	Name     string `xmlrpc:"name"`
	Size     int    `xmlrpc:"size"`
	RegionID int    `xmlrpc:"datacenter_id"`
	State    string `xmlrpc:"state"`
	Type     string `xmlrpc:"type"`
	VM       []int  `xmlrpc:"vms_id"`
	BootDisk bool   `xmlrpc:"is_boot_disk"`
}

type diskSpecv4 struct {
	RegionID int    `xmlrpc:"datacenter_id"`
	Name     string `xmlrpc:"name"`
	Size     int    `xmlrpc:"size"` // in MB
}

type diskFilterv4 struct {
	ID       int    `xmlrpc:"id"`
	RegionID int    `xmlrpc:"datacenter_id"`
	Name     string `xmlrpc:"name"`
	VMID     int    `xmlrpc:"vm_id"`
}

// CreateDisk creates a new empty data disk
//
// If left unspecified, newDisks's `Name` will be generated by Gandi's API and
// `Size` will default to 10GB
func (h Hostingv4) CreateDisk(newDisk DiskSpec) (Disk, error) {
	var fn = "CreateDisk"
	if newDisk.RegionID == "" {
		return Disk{}, &HostingError{fn, "DiskSpec", "RegionID", ErrNotProvided}
	}

	diskv4, err := toDiskSpecv4(newDisk)
	if err != nil {
		return Disk{}, err
	}
	disk, _ := structToMap(diskv4)

	response := Operation{}
	params := []interface{}{disk}
	log.Printf("[INFO] Creating Disk %s...", newDisk.Name)
	err = h.Send("hosting.disk.create", params, &response)
	if err != nil {
		return Disk{}, err
	}
	if err := h.waitForOp(response); err != nil {
		return Disk{}, err
	}
	log.Printf("[INFO] Disk %s(ID: %d) created!", newDisk.Name, response.DiskID)

	return h.diskFromID(response.DiskID)
}

// CreateDiskFromImage creates a disk with the same data as `srcDisk`
//
// If the size is not specified for `newDisk`
// it will be created with the size of the source disk, `srcDisk`
func (h Hostingv4) CreateDiskFromImage(newDisk DiskSpec, srcDisk DiskImage) (Disk, error) {
	var fn = "CreateDiskFromImage"
	if srcDisk.DiskID == "" {
		return Disk{}, &HostingError{fn, "DiskImage", "DiskID", ErrNotProvided}
	}
	if srcDisk.RegionID != newDisk.RegionID {
		return Disk{}, &HostingError{fn, "DiskSpec/DiskImage", "RegionID", ErrMismatch}
	}

	diskv4, err := toDiskSpecv4(newDisk)
	if err != nil {
		return Disk{}, err
	}
	disk, _ := structToMap(diskv4)
	imageid, err := strconv.Atoi(srcDisk.DiskID)
	if err != nil {
		return Disk{}, &HostingError{fn, "DiskImage", "DiskID", ErrParse}
	}

	response := Operation{}
	params := []interface{}{disk, imageid}
	log.Printf("[INFO] Creating Disk %s...", newDisk.Name)
	err = h.Send("hosting.disk.create_from", params, &response)
	if err != nil {
		return Disk{}, err
	}
	if err := h.waitForOp(response); err != nil {
		return Disk{}, err
	}

	log.Printf("[INFO] Disk %s(ID: %d) created!", newDisk.Name, response.DiskID)
	return h.diskFromID(response.DiskID)
}

// ListDisks lists every disk
func (h Hostingv4) ListDisks() ([]Disk, error) {
	return h.DescribeDisks(DiskFilter{})
}

// DiskFromName is a helper function to get a Disk given its name
//
// If the Disk does not exist or an error occurred it returns an empty Disk,
// use DescribeDisks with an appropriate DiskFilter to get more details
// on the possible errors
func (h Hostingv4) DiskFromName(name string) Disk {
	disks, err := h.DescribeDisks(DiskFilter{Name: name})
	if err != nil || len(disks) < 1 {
		return Disk{}
	}

	return disks[0]
}

// DescribeDisks returns a list of disks filtered with the options provided in `diskFilter`
func (h Hostingv4) DescribeDisks(diskfilter DiskFilter) ([]Disk, error) {
	filterv4, err := toDiskFilterv4(diskfilter)
	if err != nil {
		return nil, err
	}
	filter, _ := structToMap(filterv4)

	response := []diskv4{}
	params := []interface{}{}
	if len(filter) > 0 {
		params = append(params, filter)
	}
	// disk.list and disk.info return the same information
	err = h.Send("hosting.disk.list", params, &response)
	if err != nil {
		return nil, err
	}

	var disks []Disk
	for _, disk := range response {
		disks = append(disks, fromDiskv4(disk))
	}
	return disks, nil
}

// DeleteDisk deletes the Disk `disk`
//
// A disk won't be deleted if it is still attached to a VM
func (h Hostingv4) DeleteDisk(disk Disk) error {
	var fn = "DeleteDisk"
	if disk.ID == "" {
		return &HostingError{fn, "Disk", "ID", ErrNotProvided}
	}

	diskid, err := strconv.Atoi(disk.ID)
	if err != nil {
		return &HostingError{fn, "Disk", "ID", ErrParse}
	}

	response := Operation{}
	params := []interface{}{diskid}
	err = h.Send("hosting.disk.delete", params, &response)
	if err != nil {
		return err
	}
	err = h.waitForOp(response)
	return err
}

// ExtendDisk extends `disk.Size` by `size` (original size + `size`)
//
// Disks cannot shrink in size
// `size` is in GB
func (h Hostingv4) ExtendDisk(disk Disk, size uint) (Disk, error) {
	var fn = "ExtendDisk"
	if disk.ID == "" {
		return Disk{}, &HostingError{fn, "Disk", "ID", ErrNotProvided}
	}
	// size is given in GB and API expects MB
	newSize := disk.Size*1024 + int(size)*1024
	diskupdate := map[string]int{"size": newSize}
	diskid, err := strconv.Atoi(disk.ID)
	if err != nil {
		return Disk{}, &HostingError{fn, "Disk", "ID", ErrParse}
	}

	response := Operation{}
	request := []interface{}{diskid, diskupdate}
	err = h.Send("hosting.disk.update", request, &response)
	if err != nil {
		return Disk{}, err
	}
	if err := h.waitForOp(response); err != nil {
		return Disk{}, err
	}

	return h.diskFromID(response.DiskID)
}

// RenameDisk changes the name of `disk` to `newName`
func (h Hostingv4) RenameDisk(disk Disk, newName string) (Disk, error) {
	var fn = "RenameDisk"
	if disk.ID == "" {
		return Disk{}, &HostingError{fn, "Disk", "ID", ErrNotProvided}
	}
	diskupdate := map[string]string{"name": newName}
	diskid, err := strconv.Atoi(disk.ID)
	if err != nil {
		return Disk{}, &HostingError{fn, "Disk", "ID", ErrParse}
	}

	response := Operation{}
	request := []interface{}{diskid, diskupdate}
	err = h.Send("hosting.disk.update", request, &response)
	if err != nil {
		return Disk{}, err
	}
	err = h.waitForOp(response)
	if err != nil {
		return Disk{}, err
	}

	return h.diskFromID(response.DiskID)
}

// Helper functions

// Obtain a Hosting Disk from an integer ID (v4 representation)
func (h Hostingv4) diskFromID(id int) (Disk, error) {
	response := diskv4{}
	params := []interface{}{id}
	err := h.Send("hosting.disk.info", params, &response)
	if err != nil {
		return Disk{}, err
	}
	disk := fromDiskv4(response)
	return disk, nil
}

// Conversion functions for Disks in Gandi v4

// Hosting DiskSpec -> v4 DiskSpec
func toDiskSpecv4(disk DiskSpec) (diskSpecv4, error) {
	region, err := strconv.Atoi(disk.RegionID)
	if err != nil {
		return diskSpecv4{}, internalParseError("DiskSpec", "RegionID")
	}
	return diskSpecv4{
		RegionID: region,
		Name:     disk.Name,
		Size:     disk.Size * 1024,
	}, nil
}

// Hosting DiskFilter -> v4 DiskFilter
func toDiskFilterv4(disk DiskFilter) (diskFilterv4, error) {
	region := toInt(disk.RegionID)
	if region == -1 {
		return diskFilterv4{}, internalParseError("DiskFilter", "RegionID")
	}

	id := toInt(disk.ID)
	if id == -1 {
		return diskFilterv4{}, internalParseError("DiskFilter", "ID")
	}

	vmid := toInt(disk.VMID)
	if vmid == -1 {
		return diskFilterv4{}, internalParseError("DiskFilter", "VMID")
	}
	return diskFilterv4{
		RegionID: region,
		ID:       id,
		VMID:     vmid,
		Name:     disk.Name,
	}, nil
}

// v4 Disk -> Hosting Disk
func fromDiskv4(disk diskv4) Disk {
	id := strconv.Itoa(disk.ID)
	region := strconv.Itoa(disk.RegionID)
	var vms []string
	for _, vm := range disk.VM {
		vm := strconv.Itoa(vm)
		vms = append(vms, vm)
	}
	return Disk{
		ID:       id,
		Name:     disk.Name,
		Size:     disk.Size / 1024,
		RegionID: region,
		State:    disk.State,
		Type:     disk.Type,
		VM:       vms,
		BootDisk: disk.BootDisk,
	}
}
